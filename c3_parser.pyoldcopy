#!/usr/bin/python
# title            :c3_parser.py
# description      :This script preprocesses the IDL language mostly defined in macro 
#                  and send to the 2nd stage to generagte the AST and the final interface code in C
# author           :Jiguo Song
# date             :20150817
# version          :0.1
# notes            :
# python_version   :2.6.6
#
# Input : this file should run on the defined macros in cidl_gen.h and cidl.h
# Output: interface recovery code in C 
#==============================================================================

# Rules For Constructing Variable Name
#
#  Characters Allowed :
#     Underscore(_)
#     Capital Letters (A-Z)
#     Small Letters (a-z)
#     Digits (0-9)
#
#  Blanks & Commas are not allowed
#  No Special Symbols other than underscore(_) are allowed
#  First Character should be alphabet or Underscore
#  Variable name Should not be Reserved Word

# We define the following delimiter:
#  SCD -- Start of C3 Delimiter
#  ECD -- End of C3 Delimiter
#  CD --  C3 Delimiter

from __future__ import print_function
import sys, os, re 
from pprint import pprint
from pycparser import parse_file, preprocess_file
from pycparser import c_parser, c_ast, c_generator
sys.path.extend(['.', '..'])

import c3_gen, keywords

idl_parse_func_result = []  # global string to save parsed func info
idl_parse_tuple_result = []  # global string to save parsed tuple info


class StructVisitor(c_ast.NodeVisitor):
    def visit_Struct(self, node):
        result.add_tuple()
        parse_structure_info('TP', node.decls)
        parse_structure_info('SM', node.decls)
        pprint (result.tuple[-1].info)    
    
class FuncDeclVisitor(c_ast.NodeVisitor):
    def visit_FuncDecl(self, node):
        result.tuple[-1].add_function()
        parse_a_func(node, "funcdecl")
        pprint (result.tuple[-1].functions[-1].info)
         
class PtrDeclVisitor(c_ast.NodeVisitor):
    def visit_PtrDecl(self, node):
        print_logo('pointer')
        print('%s' % (node.quals))
        print('%s' % (node.type.declname))
        print('%s' % (node.type.type.names))

class StructRefVisitor(c_ast.NodeVisitor):
    def visit_StructRef(self, node):
        print_logo('struct ref field')
        print('%s' % (node.field))
         
class FuncDefVisitor(c_ast.NodeVisitor):
    def visit_FuncDef(self, node):
        global idl_parse_result 
        
        idl_result = []      
        func_name = []
        func_params = []        
        decl = node.decl

        # begin of a function
        func_name.append(decl.name)
        idl_result.append(func_name)
        
        # parameters of a function        
        for param_decl in decl.type.args.params:
            func_params = walk_parameters(param_decl)
            idl_result.append(func_params)
        
        # return of a function        
        func_return = parse_idl_str('CD', str(get_type_name(decl)[0]))
        if (not func_return[0]):
            func_return[0] = decl.type.type.type.names[0]
        idl_result.append(func_return)
        
        idl_parse_func_result.append(idl_result)        
           
           
class ParamListVisitor(c_ast.NodeVisitor):
    def visit_ParamList(self, node):
        print_logo('paramlist')
        print('%s' % (node.params))
        for param_decl in node.params:
            print(' ')
            print('Arg name: %s' % param_decl.name)
            param_str = param_decl.type.__class__.__name__
            print('node type: %s' % param_str)
            if (param_str == 'PtrDecl'):
                print('ptrdecl: %s' % param_decl.type.type.type.names)
            if (param_str == 'FuncDecl'):
                for param_decl in param_decl.type.args.params:
                    print('Arg name: %s' % param_decl.name)
         
def ptrdecl():        
    generator = c_generator.CGenerator()
    print(generator.visit(ast))
        
def process_para(param_node):
    if hasattr(param_node, 'type'):
        param_node.type.show(nodenames=True, offset=6)
        param_str = param_node.type.__class__.__name__
        if (param_str == 'PtrDecl' or param_str == 'TypeDecl' or
           param_str == 'IdentifierType'
           ):
            vlist = [getattr(param_node.type, n) for n in param_node.type.attr_names]
            attrstr = ', '.join('%s' % v for v in vlist)
            print('<<<attstr: ' + attrstr + ' >>>')
            for (child) in param_node.children():
                process_para(child)

def print_logo(name):
    print("************************")  
    print("   " + name + "     ")  
    print("************************")
    print()    
    
def explain_c_decl(c_decl):

    parser = c_parser.CParser()

    try:
        node = parser.parse(c_decl, filename='<stdin>')
    except c_parser.ParseError:
        e = sys.exc_info()[1]
        return "Parse error:" + str(e)

    if (not isinstance(node, c_ast.FileAST) or
        not isinstance(node.ext[-1], c_ast.Decl)
        ):
        return "Not a valid declaration"

    return _explain_decl_node(node.ext[-1])


def _explain_decl_node(decl_node):
    storage = ' '.join(decl_node.storage) + ' ' if decl_node.storage else ''

    return (decl_node.name + 
            " is a " + 
            storage + 
            _explain_type(decl_node.type))
                    
def _explain_type(decl):
    """ Recursively goes through a type decl node
    """
    typ = type(decl)

    if typ == c_ast.TypeDecl:
        quals = ' '.join(decl.quals) + ' ' if decl.quals else ''
        return quals + _explain_type(decl.type)
    elif typ == c_ast.Typename or typ == c_ast.Decl:
        return _explain_type(decl.type)
    elif typ == c_ast.IdentifierType:
        return ' '.join(decl.names)
    elif typ == c_ast.PtrDecl:
        quals = ' '.join(decl.quals) + ' ' if decl.quals else ''
        return quals + 'pointer to ' + _explain_type(decl.type)
    elif typ == c_ast.ArrayDecl:
        arr = 'array'
        if decl.dim: arr += '[%s]' % decl.dim.value

        return arr + " of " + _explain_type(decl.type)

    elif typ == c_ast.FuncDecl:
        if decl.args:
            params = [_explain_type(param) for param in decl.args.params]
            args = ', '.join(params)
        else:
            args = ''

        return ('function(%s) returning ' % (args) + 
                _explain_type(decl.type))
        
def get_class_name(node):
    return node.__class__.__name__
       
def get_type_name(node):
    return node.type.type.type.names

def get_dec_type_name(node):
    return node.type.type.names
       
def find_in_string(target_str, str):
    match = re.search(r"[^a-zA-Z](" + target_str + ")[^a-zA-Z]", str) 
    if match is None:
        return None
    return match.string[match.start(1):match.end(1)]    

def parse_idl_str(delimiter, mystr):
    ret = []    

    pattern = "(?<=" + delimiter + ")(?:(?!" + \
              delimiter + ").){5,}(?=" + delimiter + ")"

    last_str = ""
    for match in re.finditer(pattern, mystr, re.I):
        result_str = match.group()
        result_str = result_str[1:-1]
        ret.append(result_str)
        last_str = mystr[match.end() + len(delimiter):]
        last_str = last_str[1:]
    ret.append(last_str)    
    return ret

def parse_structure_info(pattern, struct):
        for field in struct:
            tmp = parse_idl_str(pattern, field.name)
            if (tmp[0] == ""):
                return
            tmp_tup = result.tuple[-1]
            tmp_tup_info = tmp_tup.info
            if (tmp_tup_info[tmp[0]] == ""):
                tmp_tup_info[tmp[0]] = tmp[-1]
            else:
                tmp_tup_info[tmp[0]] = [tmp_tup_info[tmp[0]], tmp[-1]]
        
def tuple_parse(ast):
    print ()
    print (".....structure....")        
    v = StructVisitor()
    v.visit(ast) 
           
                      
def walk_parameters(decl_func_node):
        func_params = parse_idl_str('CD', decl_func_node.name)
        # print (func_params)
        if (not func_params[0]):
            func_params[0] = decl_func_node.name  # # normal para

        if (func_params == ['']):
            print ("no para to save")
# ##        elif (func_params[0] == "parent_desc"):
# ##            keywords.idl_func[func_params[0]] = func_params[1]
            
        param_str = get_class_name(decl_func_node.type)
        if (param_str == 'PtrDecl'):
            func_params.append(get_type_name(decl_func_node)[0])
        if (param_str == 'TypeDecl'):
            func_params.append(decl_func_node.type.type.names[0])
        if (param_str == 'FuncDecl'):
            for param_funcdecl in decl_func_node.type.args.params:
                func_params.append(param_funcdecl.name)
            sub_return = get_class_name(decl_func_node.type.type)
            if (sub_return == 'PtrDecl'):
                ret_tp = decl_func_node.type.type.type.type.names
            if (sub_return == 'TypeDecl'):    
                ret_tp = decl_func_node.type.type.type.names                    
            func_params.append(ret_tp[0])                

        func_params.append(param_str)  # add pycparser type
        return func_params
                
def parse_a_func(node, type):
        global idl_parse_result 
        
        idl_result = []
#        func_name   = []
        func_params = [] 
        print ("")
        print (".....function....")
               
        if (type == "funcdecl"):               
            decl = node
        if (type == "funcdef"):               
            decl = node.decl
 
        # begin of a function
        # print (decl.type.declname)
#       func_name.append(decl.type.declname)
#       idl_result.append(func_name)
         
        # use th dictionary instead
        tmp_fun = result.tuple[-1].functions[-1]
        tmp_fun_info = result.tuple[-1].functions[-1].info
        tmp_fun_info[tmp_fun.name] = decl.type.declname
        
        # keywords.idl_func[keywords.func_name] = decl.type.declname
        # pprint (keywords.idl_func)
  
        # parameters of a function
        for param_decl in decl.args.params:
            func_params = walk_parameters(param_decl)
            #print (func_params)
            # swap the type and value for para (last one is the pycparser type)
            tmp = func_params[-2]
            func_params[-2] = func_params[-3]
            func_params[-3] = tmp
            
            if (func_params[0] in result.tuple[-1].functions[-1].info):
                #print (">>>>>  " + func_params[0])
                if isinstance(result.tuple[-1].functions[-1].info[func_params[0]], basestring):
                    result.tuple[-1].functions[-1].info[func_params[0]] = func_params[1:]
                elif isinstance(result.tuple[-1].functions[-1].info[func_params[0]], list):
                    result.tuple[-1].functions[-1].info[func_params[0]].append(func_params[1:])
                #idl_result.append(func_params[1:])
                #if isinstance(keywords.idl_func[func_params[0]], basestring):
                #    keywords.idl_func[func_params[0]] = func_params[1:]
                #elif isinstance(keywords.idl_func[func_params[0]], list):
                #    keywords.idl_func[func_params[0]].append(func_params[1:])                    
         # keywords.idl_func[func_params[0]] = idl_result
         # pprint (keywords.idl_func)
            
           
        # return of a function        
        func_return = parse_idl_str('CD', str(get_dec_type_name(decl)[0]))
        if (not func_return[0]):
            if (type == "funcdecl"):
                func_return[0] = decl.type.type.names[0]
            if (type == "funcdef"):
                func_return[0] = decl.type.type.type.names[0]
        result.tuple[-1].functions[-1].info[func_return[0]] = func_return[1:]
#        keywords.idl_func[func_return[0]] = func_return[1:]
   
        # the SM state of a function
#        pprint (keywords.idl_func)  
        #idl_result.append(func_return)
        #exit()        
#        idl_parse_func_result.append(idl_result)


def func_decl_parse(ast):
    v = FuncDeclVisitor()
    v.visit(ast)
    
def func_def_parse(ast):
    v = FuncDefVisitor()
    v.visit(ast)    

if __name__ == "__main__":
    if len(sys.argv) > 1:
        filename = sys.argv[1]
    else:
        filename = 'cidl.h'
        
    global result
    
    os.system("gcc -E cidl.h -o cidl_pre");        
    os.system("cat cidl_pre");
    
    # print_some_space() 
    # print_logo('<--- AST --->')    
    parser = c_parser.CParser()
    ast = parse_file('cidl_pre', use_cpp=True,
                     cpp_path='cpp',
                     cpp_args=r'-Iutils/fake_libc_include')
    # ast.show()

    result = keywords.idl_services()
    tuple_parse(ast)
    func_decl_parse(ast)
    
    ####pprint(keywords.idl_tuple)

#===============================================================================
# 
#     print ()
#     c3_gen.idl_generate(idl_parse_tuple_result,
#                     idl_parse_func_result,
#                     ast)    
#===============================================================================
    # keywords.reset_idl_func()  
#===============================================================================             
#        for param_decl in decl.type.args.params:
# #            print(' ')
# #            print('arg name: %s' % param_decl.name)
#             func_params = parse_ild_str('CD', param_decl.name)
# #            print (func_params)         
#             param_str = get_class_name(param_decl.type)
# #            print('class type: %s' % param_str)
#             if (param_str == 'PtrDecl'):
# #                type_tmp = get_type(param_decl)
# #                print('arg type: %s' % type_tmp)
#                 func_params.append(get_type_name(param_decl))
#             if (param_str == 'FuncDecl'):
#                 for param_funcdecl in param_decl.type.args.params:
# #                    print('arg name: %s' % param_funcdecl.name)
#                     func_params.append(param_funcdecl.name)
#                 sub_return = get_class_name(param_decl.type.type)
#                 if (sub_return == 'PtrDecl'):
# #                    print (param_decl.type.type.type.declname)
# #                    print (param_decl.type.type.type.type.names)
#                     ret_tp = param_decl.type.type.type.type.names
#                 if (sub_return == 'TypeDecl'):    
#  #                   print (param_decl.type.type.declname)
#  #                   print (param_decl.type.type.type.names)
#                     ret_tp = param_decl.type.type.type.names                    
#  #               print('subreturn: %s' % sub_return)
#  #               print('rt_tpye: %s' % ret_tp)
#                 func_params.append(ret_tp)                
#                 #func_params.append(sub_return)
#             if (param_str == 'TypeDecl'):
# #                    print('arg type: %s' % param_decl.type.type.names)
#                     func_params.append(param_decl.type.type.names[0])
#             func_params.append(param_str)
#===============================================================================
     
                    
