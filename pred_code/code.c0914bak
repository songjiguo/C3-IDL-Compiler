`/*****************************/
/*  ds, inside function etc. used as fake header for now */
/*****************************/
// client header start
struct IDL_desc_track

static volatile unsigned long global_fault_cnt = 0;

// TODO: consider inline for some function
static void call_update_id(int old_id, int new_id);
static int call_introspect_creator(int id);
static void call_recover_upcall(int dest_spd, int id);
static void call_restore_data(struct desc_track *desc);
static void call_save_data(int id, void *data);

static struct desc_track *call_desc_alloc();
static void call_desc_dealloc(struct desc_track *desc);
static struct desc_track *call_desc_lookup(int id);
static struct desc_track *call_desc_update(int id);
static void call_desc_rec_state(struct desc_track *desc);
static void call_desc_cons(struct desc_track *desc, IDL_desc_track_fields);

// client header end

///////////////////////////////////////////////
/*****************************/
/* client block_cli_if_invoke */
/*****************************/

// block_cli_if_invoke pred 1 start
desc_dep_create_same|desc_dep_create_diff
create
// block_cli_if_invoke pred 1 end
// block_cli_if_invoke 1 start
static void block_cli_if_invoke_IDL_fname(IDL_parsdecl) {
	struct desc_track *parent_desc = NULL;
	if ((parent_desc = call_desc_lookup(IDL_parent_id))) {
		IDL_parent_id = parent_desc->server_id;
	}
	
	//block_cli_if_invoke_ser_intro_IDL_fname(IDL_params, IDL_parent_id);
	CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
	if (ret == -1) {   // desc not exist  TODO: change to error code
		block_cli_if_recover(IDL_parent_id);
		CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
	}


}
// block_cli_if_invoke 1 end

// block_cli_if_invoke pred 2 start
desc_dep_create_single
create
// block_cli_if_invoke pred 2 end
// block_cli_if_invoke 2 start
static void block_cli_if_invoke_IDL_fname(IDL_parsdecl) {
	CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
}
// block_cli_if_invoke 2 end

// block_cli_if_invoke pred 3 start
mutate|terminate
// block_cli_if_invoke pred 3 end
// block_cli_if_invoke 3 start
static void block_cli_if_invoke_IDL_fname(IDL_parsdecl) {
	struct desc_track *desc = NULL;
	if ((desc = call_desc_lookup(IDL_id))) {
		if (desc->fault_cnt != global_fault_cnt) {
			desc->fault_cnt = global_fault_cnt;
			block_cli_if_recover(IDL_id);
			block_cli_if_recover_subtree(IDL_id);
		}
		call_update_id(IDL_id, desc->server_id);
		CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
	} else {
		//block_cli_if_invoke_ser_intro_IDL_fname (IDL_params, IDL_id);
		CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
		if (ret == -1) {   // desc not exist  TODO: change to error code
			block_cli_if_recover(IDL_id);
			CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
		}
	}
}
// block_cli_if_invoke 3 end

///////////////////////////////////////////////
/*****************************/
/* client block_cli_if_invoke_ser_intro */
/*****************************/
// block_cli_if_invoke_ser_intro pred 1 start

// block_cli_if_invoke_ser_intro pred 1 end

// block_cli_if_invoke_ser_intro 1 start
static void block_cli_if_invoke_ser_intro_IDL_fname(IDL_parsdecl, int id) {

	CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
	
	if (ret == -1) {   // desc not exist  TODO: change to error code
		block_cli_if_recover(id);
		CSTUB_INVOKE(ret, fault, uc, IDL_pars_len, IDL_params);
	}
}
// block_cli_if_invoke_ser_intro 1 end

///////////////////////////////////////////////
/*****************************/
/* client block_cli_if_recover */
/*****************************/
// block_cli_if_recover pred 1 start
desc_global_true
// block_cli_if_recover pred 1 end
// block_cli_if_recover 1 start
static void block_cli_if_recover(int id) {
	spdid_t creater_component;
	
	assert(id);
	creater_component = call_introspect_creator(id);
	assert(creater_component);
	
	if (creater_component != cos_spd_id()) {
		call_recover_upcall(creater_component, id);
	} else {
		block_cli_if_basic_id(id);
	}
}
// block_cli_if_recover 1 end

// block_cli_if_recover pred 2 start
desc_global_false
// block_cli_if_recover pred 2 end
// block_cli_if_recover 2 start
static void block_cli_if_recover(int id) {
	block_cli_if_basic_id(id);
}
// block_cli_if_recover 2 end

///////////////////////////////////////////////
/*****************************/
/* client block_cli_if_basic_id */
/*****************************/
// block_cli_if_basic_id pred 1 start
desc_dep_create_same
// block_cli_if_basic_id pred 1 end
// block_cli_if_basic_id 1 start
static void block_cli_if_basic_id(int id) {
	assert(id);
	struct desc_track *desc = call_desc_lookup(id);
	assert(desc);
	
	int retval = 0;
	retval = block_cli_if_recover_init(desc);
	
	if (!retval) {
		id = desc->parent_id;
		block_cli_if_recover(id);
	}
	
	block_cli_if_recover_data(desc);
}
// block_cli_if_basic_id 1 end

// block_cli_if_basic_id pred 2 start
desc_create_single
// block_cli_if_basic_id pred 2 end
// block_cli_if_basic_id 2 start
static void block_cli_if_basic_id(int id) {

	assert(id);
	struct desc_track *desc = call_desc_lookup(id);
	assert(desc;)

	int retval = 0;
	retval = block_cli_if_recover_init(desc);
	block_cli_if_recover_data)(desc);
}
// block_cli_if_basic_id 2 end

///////////////////////////////////////////////
/**************************************/
/* client block_cli_if_recover_upcall */
/**************************************/

// block_cli_if_recover_upcall pred 1 start
desc_global_true
// block_cli_if_recover_upcall pred 1 end

// block_cli_if_recover_upcall 1 start
static void block_cli_if_recover_upcall(int id) {
	assert(id);
	block_cli_if_recover(id);
	block_cli_if_recover_subtree(id);
}
// block_cli_if_recover_upcall 1 end

///////////////////////////////////////////////
/**************************************/
/* client block_cli_if_recover_subtree */
/**************************************/
// block_cli_if_recover_subtree pred 1 start
desc_close_subtree
desc_create_diff
terminate
// block_cli_if_recover_subtree pred 1 end
// block_cli_if_recover_subtree 1 start
static void block_cli_if_recover_subtree(int id) {
	assert(id);
	struct desc_track *desc = call_desc_lookup(id);
	assert(desc);
	
	struct desc_track *child_desc_list = desc->child_desc_list;
	
	for ((child_desc) = FIRST_LIST((child_desc_list), next, prev) ;	  
	     (child_desc) != (child_desc_list) ;
	     (child_desc) = FIRST_LIST((child_desc), next, prev)) {
		block_cli_if_basic_id(child_desc->id);
		if (child_desc->dest_spd != cos_spd_id()) {
			call_recover_upcall(child_desc->dest_spd, child_desc->id);
		} else {
			id = child_desc->id;
			block_cli_if_recover_subtree(id);
		}
	}
}
// block_cli_if_recover_subtree 1 end

///////////////////////////////////////////////
/*****************************/
/* client block_cli_if_track */
/*****************************/

// block_cli_if_track pred 1 start
create
// block_cli_if_track pred 1 end
// block_cli_if_track 1 start
static void block_cli_if_track_IDL_fname(int ret, IDL_parsdecl) {
	struct desc_track *desc = call_desc_lookup(ret);
	assert(desc);

	call_desc_save(desc, ret, IDL_params);
}
// block_cli_if_track 1 end

// block_cli_if_track pred 2 start
desc_dep_close_remove
terminate
// block_cli_if_track pred 2 end
// block_cli_if_track 2 start
static void block_cli_if_track_IDL_fname(int ret, IDL_parsdecl) {
	struct desc_track *desc = call_desc_lookup(ret);
	assert(desc);
	call_desc_dealloc(desc);
}
// block_cli_if_track 2 end

// block_cli_if_track pred 3 start
desc_dep_close_keep
terminate
// block_cli_if_track pred 3 end
// block_cli_if_track 3 start
static void block_cli_if_track_IDL_fname(int ret, IDL_parsdecl) {
	struct desc_track *desc = call_desc_lookup(ret);
	assert(desc);

	call_desc_dealloc(desc);

	// TODO: this needs to be changed
	/* struct desc_track *child_desc_list = desc->child_desc_list;	 */
	/* if (EMPTY_LIST(child_desc_list)) { */
	/* 	call_desc_dealloc(desc); */
	/* } */
}
// block_cli_if_track 3 end

///////////////////////////////////////////////
/************************************/
/* client block_cli_if_recover_init */
/************************************/
// block_cli_if_recover_init pred 1 start
create
// block_cli_if_recover_init pred 1 end
// block_cli_if_recover_init 1 start
static int block_cli_if_recover_init(struct desc_track *desc) {
	assert(desc);
	return IDL_fname(desc->saved_params);
	
}
// block_cli_if_recover_init 1 end

///////////////////////////////////////////////
/************************************/
/* client block_cli_if_recover_data */
/************************************/
// block_cli_if_recover_data pred 1 start
resc_has_data_true
// block_cli_if_recover_data pred 1 end
// block_cli_if_recover_data 1 start
static void block_cli_if_recover_data(struct desc_track *desc) {
	assert(desc);
	call_restore_data(desc);
}
// block_cli_if_recover_data 1 end

///////////////////////////////////////////////
/************************************/
/* client block_cli_if_save_data    */
/************************************/
// block_cli_if_save_data pred 1 start
desc_has_data_true
// block_cli_if_save_data pred 1 end
// block_cli_if_save_data 1 start
static void block_cli_if_save_data(int id, void *data) {
	call_save_data(id, data);
}
// block_cli_if_save_data 1 end

///////////////////////////////////////////////
/********************************************/
/* client interface recovery upcall_entry   */
/********************************************/
// block_cli_if_recover_upcall_entry pred 1 start
desc_global_true
// block_cli_if_recover_upcall_entry pred 1 end
// block_cli_if_recover_upcall_entry 1 start
static void block_cli_if_recover_upcall_entry(int id) {
	block_cli_if_recover_upcall(id);
}
// block_cli_if_recover_upcall_entry 1 end



